"""Transformer serialization utilities."""

import inspect
import json
import os
import pickle
import uuid

from foreshadow.exceptions import TransformerNotFound
from foreshadow.utils import get_cache_path


_registry = {}


def register_transformer(class_, name):
    """Register a transformer so it can be deserialized.

    Args:
        class_: Class definition object.
        name: Name used to refer to the object

    Raises:
        KeyError: If the key is already in the registry

    """
    # Name space tomfoolery
    import foreshadow.core

    if name != "SerializerMixin":
        if name not in _registry:
            foreshadow.core._registry[name] = class_
        else:
            raise KeyError("{} is already in the registry".format(name))


def get_transformer(class_name):
    """Get a registered transformer from the registry.

    Args:
        class_name (str): Transformer name

    Returns:
        The class definition

    Raises:
        TransformerNotFound: The transformer was not pandas wrapped and thus,
            wasn't added to the registry

    """
    # Name space tomfoolery
    from foreshadow.core import _registry

    try:
        return _registry[class_name]
    except KeyError:
        raise TransformerNotFound(
            "{} was not pandas wrapped, this is required for automatic "
            "deserialization.".format(class_name)
        )


def deser_json(data):
    """Deserialize JSON data.

    Args:
        data (dict): A dictionary generated by a subclass of `SerializerMixin`.

    Returns:
        The constructed object.

    """
    return get_transformer(data["transformer"])().set_params(**data["data"])


def deser_pickle_inline(data):
    """Deserialize an inlined pickle transformer.

    Args:
        data (dict): A dictionary generated by a subclass of `SerializerMixin`.

    Returns:
        The constructed object.

    """
    return pickle.loads(bytearray.fromhex(data["data"]))


def deser_pickle_disk(data):
    """Deserialize an pickled transformer saved to a cache directory.

    Args:
        data (dict): A dictionary generated by a subclass of `SerializerMixin`.

    Returns:
        The constructed object.

    """
    fpath = data["data"]
    with open(fpath, "rb") as fopen:
        return pickle.load(fopen)


def deserialize(data):
    """Deserialize data as specified.

    Args:
        data (dict): The data serialize.

    Returns:
        The object.

    Raises:
        ValueError: If the serialization method is not one of the allowable
            methods

    """
    options = {
        "json": deser_json,
        "pickle_inline": deser_pickle_inline,
        "pickle_disk": deser_pickle_disk,
    }

    try:
        method = data["method"]
        return options[method](data)
    except KeyError:
        raise ValueError(
            "Serialization method must be one of {}".format(options.keys())
        )


def from_disk(path):
    """Load A json representation of a transformer from disk.

    Args:
        path (str): The path to load the data from.

    Returns:
        The constructed object.

    """
    with open(path, "r") as fopen:
        return deserialize(json.load(fopen))


def _retrieve_name(var):
    """Get the name of defined var.

    Args:
        var: python object

    Returns:
        str: Instance name

    """
    # Source: https://stackoverflow.com/a/40536047
    for fi in reversed(inspect.stack()):
        names = [
            var_name
            for var_name, var_val in fi.frame.f_locals.items()
            if var_val is var
        ]
        if len(names) > 0:
            return names[0]


class SerializerMixin:
    """Mixin class that provides convenience serialization methods."""

    def pickle_cache_path(self, cache_path=None):
        """Get the pickle cache path of a transformer.

        Uses a generated UUID and the class name to come up with a unique
        filename.

        Args:
            cache_path (str, optional): override the default cache_path which
                is in the root of the user's directory.

        Returns:
            str: A string representation of the file path including the \
                filename.

        """
        if cache_path is None:
            cache_path = get_cache_path()

        fname = self.__class__.__name__ + uuid.uuid4().hex
        fpath = "{}.pkl".format(fname)
        path = os.path.join(cache_path, fpath)

        return path

    def ser_json(self, deep=True):
        """Get the params of a transformer, its initialization state.

        Args:
            deep (bool): If True, will return the parameters for this estimator
                recursively

        Returns:
            dict: The initialization parameters of the transformer.

        """
        return self.get_params(deep)

    def ser_pickle_inline(self, protocol=pickle.HIGHEST_PROTOCOL):
        """Convert transformer to pickle then to a hex form.

        Args:
            protocol: A pickle compression number

        Returns:
            A string representation of the pickle dump

        """
        return pickle.dumps(self, protocol=protocol).hex()

    def ser_pickle_disk(
        self, cache_path=None, protocol=pickle.HIGHEST_PROTOCOL
    ):
        """Convert transformer to pickle and save it disk in a cache directory.

        Args:
            cache_path (str): Override the default cache path which is in the
                root of the user directory
            protocol: The pickle compression protocol

        Returns:
            str: The path the data was saved to.

        """
        fpath = self.pickle_cache_path(cache_path)
        with open(fpath, "wb+") as fopen:
            pickle.dump(self, fopen, protocol=protocol)

        return fpath

    def serialize(self, method="json", **kwargs):
        """Serialize data as specified.

        If you would like to save the transformer parameters without saving
        its state in a human readable form, use `json`. If you would like to
        save the transformer with its internal state use `pickle_inline` to
        save it in its hex form in the json. If you would like a more space
        efficient form save use `pickle_disk` to save it a cache directory in
        the root (~/.foreshadow/cache) that must be manually cleaned.

        Note:
            See the individual serialization methods
            `get_json <foreshadow.core.SerializerMixin.get_json>` and
            `get_pickle <foreshadow.core.SerializerMixin.get_pickle>` for
            additional keyword arguments that are passed through the serialize
            method to those respective methods.

        Args:
            method (str): A choice between `json` and `pickle` to serialize a
                string.
            **kwargs: The keyword arguments to pass to the serialization method

        Returns:
            str: The appropriate string representation of the serialization.

        Raises:
            ValueError: If the serialization is not of the allowable options.

        """
        options = {
            "json": self.ser_json,
            "pickle_inline": self.ser_pickle_inline,
            "pickle_disk": self.ser_pickle_disk,
        }

        try:
            data = options[method](**kwargs)
        except KeyError:
            raise ValueError(
                "Serialization method must be one of {}".format(options.keys())
            )

        return {
            "transformer": self.__class__.__name__,
            "method": method,
            "data": data,
        }

    def to_disk(self, path, method="json", **kwargs):
        """Save a serialized form a transformer to disk.

        Args:
            path: The path to save the transformer
            method: The method to use to serialize the transformer, see
                `serialize` to see all options
            **kwargs: Any further options to pass to serialize

        """
        with open(path, "w+") as fopen:
            json.dump(self.serialize(method=method, **kwargs), fopen)


# if __name__ == "__main__":
#     import numpy as np
#     from foreshadow.transformers.concrete import StandardScaler
#
#     ss = StandardScaler()
#     test = np.arange(10).reshape((-1, 1))
#
#     ss.fit(test)
#
#     ser = ss.serialize()
#     deser = deserialize(ser)
#
#     import pdb
#
#     pdb.set_trace()
